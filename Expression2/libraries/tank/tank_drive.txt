@persist [Engines__]:array
@persist [LGearbox__, RGearbox__, CVTGearbox__]:entity
@persist [MaxClutch__, BrakeForce__, MaxThrottle__, IdleThrottle__]:number

#[ Uncomment to enable debugging.
@outputs [Engines__]:array
@outputs [LGearbox__, RGearbox__, CVTGearbox__]:entity
@outputs [MinClutch__, MaxClutch__, BrakeForce__, MaxThrottle__, IdleThrottle__]:number
#]#

# This is required.
#include "libraries/tank/tank_core"

# Events
function event_inputUpdate(Callbacks:array)
{
	if(InputData__:exists("source"))
	{
		local POD = InputData__["source", wirelink]
		InputData__["W", number] = POD["W", number]
		InputData__["A", number] = POD["A", number]
		InputData__["S", number] = POD["S", number]
		InputData__["D", number] = POD["D", number]
		InputData__["Space", number] = POD["Space", number]
		InputData__["speed", number] = Base__:vel():length()
	}	
}
function event_mobilityUpdate(Callbacks:array)
{
	local W = InputData__["W", number]
	local A = InputData__["A", number]
	local S = InputData__["S", number]
	local D = InputData__["D", number]
	local Space = InputData__["Space", number]
	
	local LGearbox = LGearbox__
	local RGearbox = RGearbox__
	local Speed = InputData__["speed", number]
	
	LGearbox:acfClutchLeft(MinClutch__)
	LGearbox:acfClutchRight(MinClutch__)
	RGearbox:acfClutchLeft(MinClutch__)
	RGearbox:acfClutchRight(MinClutch__)

	local LGear = (W & !A & !D ? 1 : (S & !A & !D ? 2 : (D ? 1 : (A ? 2 : 0))))
	local RGear = (W & !A & !D ? 1 : (S & !A & !D ? 2 : (D ? 2 : (A ? 1 : 0))))

	Throttle = (W | S ? MaxThrottle__ : (A | D ? MaxThrottle__ :  IdleThrottle__))
	for(I=1, Engines__:count())
	{
		Engines__[I, entity]:acfThrottle(Throttle)
	}

	LGearbox:acfShift(LGear)
	RGearbox:acfShift(RGear)

	LGearbox:acfClutchLeft((A | D ? MaxClutch__ : MinClutch__))
	RGearbox:acfClutchRight((A | D ? MaxClutch__ : MinClutch__))
	
	LGearbox:acfBrake(0)
	RGearbox:acfBrake(0)
	
	if(A | D)
	{
		if(!Space)
		{
			if(S)
			{
				LGearbox:acfClutchRight((D ? MaxClutch__ : MinClutch__))
				LGearbox:acfBrakeRight((D ? BrakeForce__*3 : 0))
				RGearbox:acfClutchLeft((A ? MaxClutch__ : MinClutch__))
				RGearbox:acfBrakeLeft((A ? BrakeForce__*3 : 0))
			} else {
				LGearbox:acfClutchRight((A ? MaxClutch__ : MinClutch__))
				LGearbox:acfBrakeRight((A ? BrakeForce__*3 : 0))
				RGearbox:acfClutchLeft((D ? MaxClutch__ : MinClutch__))
				RGearbox:acfBrakeLeft((D ? BrakeForce__*3 : 0))
			}
		}
	} elseif(!W & !S) {
		LGearbox:acfBrake(BrakeForce__*1.5)
		RGearbox:acfBrake(BrakeForce__*1.5)
	}
}
function event_tankMove(Callbacks:array) # Requires event_inputUpdate for getting current velocity.
{
	if(InputData__["speed", number] > 0)
	{
		for(I=1, Callbacks:count())
		{
			local StrCallback = Callbacks[I, string]
			StrCallback(InputData__["speed", number], Base__:angVel())
		}
	}
}

# Getters and setters
function tanklib_setIdleThrottle(IdleThrottle:number)
{
	IdleThrottle__ = IdleThrottle
}
function tanklib_setMaxThrottle(MaxThrottle:number)
{
	MaxThrottle__ = MaxThrottle
}
function tanklib_setMinClutch(MinClutch:number)
{
	MinClutch__ = MinClutch
}
function tanklib_setMaxClutch(MaxClutch:number)
{
	MaxClutch__ = MaxClutch
}
function tanklib_setEngineActive(ActiveState:number)
{
	for(I=1, Engines__:count())
	{
		Engines__[I, entity]:acfActive(ActiveState)
	}
}
function tanklib_setInputSource(Wirelink:wirelink)
{
	if(!Wirelink:entity():isValid()) { return }
	InputData__["source", wirelink] = Wirelink
}